import './responsive-image.css';
import { env, getValueOrCallback, getDestinationWidthBySize } from '@responsive-image/core';
import React, { useState } from 'react';

function _extends() {
  return _extends = Object.assign ? Object.assign.bind() : function (n) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends.apply(null, arguments);
}

const typeScore = new Map([['png', 1], ['jpeg', 1], ['webp', 2], ['avif', 3]]);
const pixelDensities = [1, 2];
function getLayout(props) {
  const layout = props.width === undefined && props.height === undefined ? 'responsive' : 'fixed';
  return layout;
}
function getSources(props) {
  const layout = getLayout(props);
  const imageTypes = Array.isArray(props.src.imageTypes) ? props.src.imageTypes : [props.src.imageTypes];
  if (layout === 'responsive') {
    return imageTypes.map(type => {
      let widths = props.src.availableWidths;
      if (!widths) {
        widths = env.deviceWidths;
      }
      const sources = widths.map(width => {
        const url = props.src.imageUrlFor(width, type);
        return `${url} ${width}w`;
      });
      return {
        srcset: sources.join(', '),
        sizes: props.sizes ?? (props.size ? `${props.size}vw` : undefined),
        type,
        mimeType: type != 'auto' ? `image/${type}` : undefined
      };
    });
  }
  const {
    width
  } = props;
  if (width === undefined) {
    return [];
  }
  return imageTypes.map(type => {
    const sources = pixelDensities.map(density => {
      const url = props.src.imageUrlFor(width * density, type);
      return `${url} ${density}x`;
    }).filter(source => source !== undefined);
    return {
      srcset: sources.join(', '),
      type,
      mimeType: type != 'auto' ? `image/${type}` : undefined
    };
  });
}
function getWidth(props) {
  const layout = getLayout(props);
  if (layout === 'responsive') {
    return getDestinationWidthBySize(props.size);
  }
  if (props.width !== undefined) {
    return props.width;
  }
  const aspectRatio = props.src.aspectRatio;
  if (aspectRatio && props.height !== undefined) {
    return props.height * aspectRatio;
  }
  return undefined;
}
function getHeight(props) {
  if (props.height !== undefined) {
    return props.height;
  }
  const width = getWidth(props);
  const aspectRatio = props.src.aspectRatio;
  if (aspectRatio && width !== undefined) {
    return Math.round(width / aspectRatio);
  }
  return undefined;
}
function getSrc(props) {
  const format = props.src.imageTypes === 'auto' ? 'auto' : undefined;
  const width = getWidth(props) || 640;
  return props.src.imageUrlFor(width, format);
}
function getClassNames(props, isLoaded, className) {
  const layout = getLayout(props);
  const classNames = ['ri-img', `ri-${layout === 'responsive' ? 'responsive' : 'fixed'}`];
  const lqipClass = props.src.lqip?.class;
  if (lqipClass && !isLoaded) {
    classNames.push(getValueOrCallback(lqipClass));
  }
  if (className) {
    classNames.push(className);
  }
  return classNames.join(' ');
}
function camelCase(kebabCase) {
  return kebabCase.replace(/(-.)/g, dashChar => dashChar.charAt(1).toUpperCase());
}
function getStyles(props, isLoaded) {
  if (isLoaded) {
    return undefined;
  }
  const styles = getValueOrCallback(props.src.lqip?.inlineStyles);
  if (!styles) {
    return undefined;
  }
  const reactStyles = {};
  for (const [property, value] of Object.entries(styles)) {
    reactStyles[camelCase(property)] = value;
  }
  return reactStyles;
}
let keyCounter = 0;
const keyMap = new WeakMap();
function ResponsiveImage(props) {
  const [loadedSrc, setLoaded] = useState(undefined);
  const {
    src,
    size,
    sizes,
    width,
    height,
    className,
    ...htmlAttributes
  } = props;
  const riProps = {
    src,
    size,
    sizes,
    width,
    height
  };
  const isLoaded = loadedSrc === src;
  let key;

  // When LQIP is used, we need to use a key, so when src changes, the img element is recreated to re-apply LQIP styles without having
  // the previous src visible (<img> is a stateful element!). Without LQIP, reuse existing DOM.
  // See also https://github.com/simonihmig/responsive-image/issues/1583#issuecomment-3315142391
  // Ideally, we would just use src as the key, but React only allows for simple values (numbers or strings) as key, so we need to use
  // a mapping of src to generated primitive keys, that ensures that we get the same key for the same src
  if (src.lqip) {
    key = keyMap.get(src);
    if (key === undefined) {
      key = keyCounter++;
      keyMap.set(src, key);
    }
  }
  const sources = getSources(riProps);
  const img = /*#__PURE__*/React.createElement("img", _extends({
    key: key,
    className: getClassNames(riProps, isLoaded, className),
    loading: htmlAttributes.loading || 'lazy',
    decoding: htmlAttributes.decoding || 'async',
    width: getWidth(riProps),
    height: getHeight(riProps),
    srcSet: src.imageTypes === 'auto' ?
    // auto format assumes only one entry in sources
    sources[0]?.srcset : undefined,
    src: getSrc(riProps)
  }, htmlAttributes, {
    "data-ri-lqip": riProps.src.lqip?.attribute,
    style: getStyles(riProps, isLoaded),
    onLoad: () => setLoaded(src)
  }));
  if (src.imageTypes === 'auto') {
    return img;
  }
  return /*#__PURE__*/React.createElement("picture", null, sources.sort((a, b) => (typeScore.get(b.type) ?? 0) - (typeScore.get(a.type) ?? 0)).map(s => /*#__PURE__*/React.createElement("source", {
    key: s.mimeType,
    srcSet: s.srcset,
    type: s.mimeType,
    sizes: s.sizes
  })), img);
}

export { ResponsiveImage };
