type ImageType = 'png' | 'jpeg' | 'webp' | 'avif';
type NonFunction = string | number | boolean | undefined | null | object | Array<unknown>;
type ValueOrCallback<T extends NonFunction> = T | (() => T);
interface Lqip {
    /**
     * While the real image is loading the image component would apply this class.
     */
    class?: ValueOrCallback<string>;
    /**
     * If set, the image component will apply a data-ri-lqip=<value> attribute, which can be used e.g. for embedded decoding information for SSR
     */
    attribute?: string;
    /**
     * Image components may apply this inline CSS (aka CSS-in-JS). Used when components make use of Shadow DOM, where CSS imports that build systems would apply to document.head would not get applied behind the Shadow DOM.
     */
    inlineStyles?: ValueOrCallback<Record<string, string | undefined>>;
}
type ImageTypeAuto = 'auto';
type ImageUrlForType = ImageType | ImageTypeAuto;
interface ImageData {
    imageTypes: ImageType[] | ImageTypeAuto;
    availableWidths?: number[];
    aspectRatio?: number;
    imageUrlFor(width: number, type?: ImageUrlForType): string | undefined;
    lqip?: Lqip;
}
interface ImageOutputResult {
    url: string;
    width: number;
    format: ImageType;
}
interface Env {
    screenWidth: number;
    physicalWidth: number;
    devicePixelRatio: number;
    deviceWidths: number[];
}
interface EnvConfig {
    deviceWidths?: number[];
    /**
     * By default the size for the `img` tag fallback is set to the largest {@link deviceWidths}.
     *
     * Set this to an explicit size if you want to change that behavior.
     */
    fallbackScreenWidth?: number;
}

declare function findMatchingImage(images: ImageOutputResult[], width: number, type: ImageType): ImageOutputResult | undefined;

declare const env: Env;
declare function getDestinationWidthBySize(size?: number): number;

declare function getConfig<C extends object = Record<string, unknown>>(namespace: string): C | undefined;
declare function setConfig<C extends object = Record<string, unknown>>(namespace: string, config: C): void;

declare function assert(message: string, check: boolean): asserts check is true;

interface ResolveImageOptions {
    /**
     * width in pixel to request the best matching image for
     */
    width?: number;
    /**
     * size in vw (0 - 100) to request the best matching image for
     */
    size?: number;
    /**
     * preferred image format
     */
    format?: ImageUrlForType;
}
declare function resolveImage(data: ImageData, { width, size, format }?: ResolveImageOptions): string | undefined;

declare function getValueOrCallback<T extends NonFunction>(valueOrCb: ValueOrCallback<T>): T;

export { assert, env, findMatchingImage, getConfig, getDestinationWidthBySize, getValueOrCallback, resolveImage, setConfig };
export type { Env, EnvConfig, ImageData, ImageOutputResult, ImageType, ImageTypeAuto, ImageUrlForType, Lqip, NonFunction, ResolveImageOptions, ValueOrCallback };
